---
description: Node.js and Express patterns for charts-router backend
globs: ["charts-router/**/*.ts", "charts-router/**/*.js", "**/server.ts", "**/middleware/**", "**/routes/**"]
alwaysApply: false
---

# Node.js & Express - Backend Patterns

## Critical Rules

1. **ES Modules**: Always use `import/export`, never `require`.
2. **Async Error Handling**: Always handle async errors, never leave unhandled promises.
3. **Type Safety**: Use TypeScript types from Express (`Request`, `Response`, `NextFunction`).

---

## Express Patterns

### Route Handlers

```typescript
// ✅ Good - Async handler with error handling
router.post('/event', async (req: Request, res: Response) => {
  try {
    const events: AnalyticsEvent[] = req.body.events || [req.body.event].filter(Boolean);
    
    if (events.length === 0) {
      return res.status(400).json({
        success: false,
        message: 'No events provided',
      });
    }

    await getAnalyticsStorage().save(events[0]);
    
    res.json({
      success: true,
      message: `Saved ${events.length} event(s)`,
    });
  } catch (error) {
    console.error('Error processing analytics event:', error);
    res.status(500).json({
      success: false,
      message: error instanceof Error ? error.message : 'Unknown error',
    });
  }
});
```

### Middleware

```typescript
// ✅ Good - Type-safe middleware
export function analyticsMiddleware(
  req: Request, 
  res: Response, 
  next: NextFunction
): void {
  const analyticsEnabled = process.env.ANALYTICS_ENABLED !== 'false';
  
  if (!analyticsEnabled) {
    return next();
  }

  // Middleware logic
  next();
}
```

### Error Handling Middleware

```typescript
// ✅ Good - Error handling middleware
app.use((err: Error, req: Request, res: Response, next: NextFunction) => {
  console.error('Unhandled error:', err);
  res.status(500).json({
    success: false,
    message: err.message,
  });
});
```

---

## File System Operations

### Use Promises API

```typescript
// ✅ Good - Promises API
import fs from 'fs/promises';

async function readLogFile(path: string): Promise<string> {
  try {
    return await fs.readFile(path, 'utf-8');
  } catch (error) {
    if (error instanceof Error && 'code' in error && error.code === 'ENOENT') {
      return ''; // File doesn't exist, return empty
    }
    throw error;
  }
}
```

### Always Handle Errors

```typescript
// ❌ Bad - Unhandled promise
fs.readFile(path, 'utf-8').then(content => {
  // Process
});

// ✅ Good - Error handling
try {
  const content = await fs.readFile(path, 'utf-8');
  // Process
} catch (error) {
  logger.error('Failed to read file:', error);
}
```

---

## Environment Variables

### Type-Safe Access

```typescript
// ✅ Good - Type-safe env access
const analyticsEnabled = process.env.ANALYTICS_ENABLED !== 'false';
const logPath = process.env.ANALYTICS_LOG_PATH || './logs/analytics.jsonl';
const debugMode = process.env.ANALYTICS_DEBUG === 'true';

// ✅ Good - With validation
function getPort(): number {
  const port = Number(process.env.PORT);
  if (isNaN(port) || port <= 0) {
    return 3000; // Default
  }
  return port;
}
```

---

## Async Patterns

### Parallel Operations

```typescript
// ✅ Good - Parallel operations
const [file1, file2] = await Promise.all([
  fs.readFile(path1, 'utf-8'),
  fs.readFile(path2, 'utf-8'),
]);
```

### Sequential with Error Handling

```typescript
// ✅ Good - Sequential with proper error handling
async function processEvents(events: AnalyticsEvent[]): Promise<void> {
  for (const event of events) {
    try {
      await validateEvent(event);
      await saveEvent(event);
    } catch (error) {
      logger.error('Failed to process event:', error);
      // Continue with next event
    }
  }
}
```

---

## Express Server Setup

### Standard Pattern

```typescript
// ✅ Good - Standard Express setup
import express, { type Request, Response } from 'express';

const app = express();

// Trust proxy for correct IP in production
app.set('trust proxy', true);

// Middleware
app.use(express.json());

// Routes
app.use('/api/analytics', analyticsRouter);

// Error handling
app.use((err: Error, req: Request, res: Response, next: NextFunction) => {
  // Handle errors
});

const PORT = Number(process.env.PORT) || 3000;
app.listen(PORT, '0.0.0.0', () => {
  console.log(`Server listening on port ${PORT}`);
});
```

---

## File Operations

### Path Handling

```typescript
// ✅ Good - Use path module
import path from 'path';

const logPath = path.join(__dirname, '../../../logs/analytics.jsonl');
const logDir = path.dirname(logPath);
```

### Directory Operations

```typescript
// ✅ Good - Ensure directory exists
async function ensureDirectory(dir: string): Promise<void> {
  try {
    await fs.access(dir);
  } catch {
    await fs.mkdir(dir, { recursive: true });
  }
}
```

---

## Logging

### Use Console with Levels

```typescript
// ✅ Good - Structured logging
if (process.env.ANALYTICS_DEBUG === 'true') {
  console.log('[Analytics] Event captured:', {
    type: event.type,
    chartType: event.chartType,
    timestamp: event.timestamp,
  });
}
```

### Error Logging

```typescript
// ✅ Good - Detailed error logging
try {
  await operation();
} catch (error) {
  console.error('Operation failed:', {
    error: error instanceof Error ? error.message : String(error),
    stack: error instanceof Error ? error.stack : undefined,
    context: { /* relevant context */ },
  });
}
```

---

## Headers and Request Data

### Safe Header Access

```typescript
// ✅ Good - Safe header access with fallback
const org = req.get('x-thoughtspot-org') || 
            req.get('x-org-id') || 
            undefined;

const ip = req.ip || req.socket.remoteAddress || 'unknown';
```

### Request Body Validation

```typescript
// ✅ Good - Validate request body
if (!req.body || typeof req.body !== 'object') {
  return res.status(400).json({
    success: false,
    message: 'Invalid request body',
  });
}
```

---

## Performance

### Avoid Blocking Operations

```typescript
// ❌ Bad - Blocking operation
res.on('finish', () => {
  fs.writeFileSync(logPath, data); // Blocks
});

// ✅ Good - Non-blocking
res.on('finish', () => {
  fs.writeFile(logPath, data, 'utf-8')
    .catch(err => console.error('Failed to write log:', err));
});
```

---

## Common Patterns

### Storage Abstraction

```typescript
// ✅ Good - Interface-based storage
interface AnalyticsStorage {
  save(event: AnalyticsEvent): Promise<void>;
  saveBatch(events: AnalyticsEvent[]): Promise<void>;
}
```

### Singleton Pattern

```typescript
// ✅ Good - Singleton for storage
let storageInstance: AnalyticsStorage | null = null;

export function getAnalyticsStorage(): AnalyticsStorage {
  if (!storageInstance) {
    storageInstance = createAnalyticsStorage({
      storageType: process.env.ANALYTICS_STORAGE_TYPE || 'file',
      logPath: process.env.ANALYTICS_LOG_PATH,
    });
  }
  return storageInstance;
}
```
